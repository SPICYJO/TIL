# Classes, Objects and Interfaces

## Class Definition
<details>
    <summary>Interface</summary>
    
```kotlin
interface Clickable {
    fun click()
    fun showOff() = println("I'm clickable!") // interface can have default method
}

interface Focusable {
    fun setFocus(b: Boolean) {
        println("I ${if (b) "got" else "lost"} focus.")
    }
    fun showOff() = println("I'm focusable!")
}

class Button: Clickable, Focusable {
    override fun click() = println("I was clicked")
    override fun showOff() { // Must define method if two interfaces provide default method for "showOff"
        super<Clickable>.show()
        super<Focusable>.show()
    }
}
```

</details>

<details>
    <summary>open, final, abstract, override modifier: default is final</summary>
    
```kotlin
open class RichButton: Clickable {
    fun disable() {} // final, cannot be overriden
    open fun animate() {}  // open, can be overriden
    override fun click() {} // overrides superclass's method, overriden method are open in default (add final to prohibit being overriden)
}

abstract class Animated {
    abstract fun animate()
    open fun stopAnimating() {} 
    fun animateTwice() {} // final in default
}
```

- In Kotlin, default modifier is `final` which helps to mitigate "fragile base class" problem


</details>

<details>
    <summary>visibility modifier: public in default</summary>


- `public`: visible from anywhere. default modifier
- `internal`: visible from same module(which means set of codes that are built together in build tool, i.e. gradle, maven)
- `protected`: can be seen in child class
- `private`: can only be seen in the same class

</details>

<details>
    <summary>nested class and inner class</summary>

```kotlin
interface State: Serializable
interface View {
    fun getCurrentState(): State
    fun restoreState(state: State)
}

class Button: View {
    override fun getCurrentState(): State = ButtonState()
    override fun restoreState(state: State) { /*...*/ }
    class ButtonState : State { /*...*/ } // Corresponds to Java's static nested class
}

class Outer {
    inner class Inner {
        fun getOuterReference(): Outer = this@Outer
    }
}
```

- (nested class) `static class A` in Java corresponds to `class A` in Kotlin
- (inner class) `class A` in Java corresponds to `inner class A` in Kotlin


</details>

<details>
    <summary>sealed class</summary>

```kotlin
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr): Int =
    when (e) {
        is Expr.Num -> e.value
        is Expr.Sum -> eval(e.right) + eval(e.left)
    }
```

- `sealed` class can be used to restrict subclass definitions

</details>

## Constructor and Property
<details>
    <summary>Class initialization</summary>

```kotlin
// Three definitions are equivalent
// Examples of primary constructors

class User constructor(_nickname: String) {
    val nickname: String
    init {
        nickname = _nickname
    }
}

class User(_nickname: String) {
    val nickname: String = _nickname
}

class User(val nickname: String)

class Address(val detail: String, val city: String = "Seoul")

val mike = User("Mike")

class RedioButton: Button() // When inheriting superclass, it should call constructor of superclass
```

```kotlin
// Examples of secondary constructors

open class View {
    constructor(ctx: Context) { /* ... */ }
    constructor(ctx: Context, attr: AttributeSet) { /* ... */ }

}

open class MyButton: View {
    constructor(ctx: Context) : this(ctx, MY_STYLE) { /* ... */ }
    constructor(ctx: Context, attr: AttributeSet): super(ctx, attr) { /* ... */ }

}

```

```kotlin
// In Kotlin, interface can have abstract property declaration

interface User {
    val nickname: String
}

class PrivateUser(override val nickname: String) : User
class SubscribingUser(val email: String) : User {
    override val nickname: String
        get() = email.substringBefore('@')  // called every time property is accessed
}

class FacebookUser(val accountId: String) : User {
    override val nickname = getFacebookName(accountId)  // called once when instance is created
}

class LengthCounter {
    var counter: Int = 0
        private set
    fun addWord(word: String) {
        counter += word.length
    }
}

```


</details>

## data class and class delegation: methods generated by compiler
<details>
    <summary>data class</summary>
    
```kotlin
data class Client(val name: String, val postalCode: Int)
```

- Kotlin compiler generates `equals`, `hashCode`, `toString` and other useful methods (e.g. `copy`) to `data class`

</details>

<details>
    <summary>class delegation</summary>
    
```kotlin
class DelegatingCollection<T> {
    innerList: Collection<T> = ArrayList<T>()
} : Collection<T> by innerList { }
```

</details>

## object keyword
<details>
    <summary>object declaration: can be used to create singleton</summary>
    
```kotlin
object Payroll {
    val allEmployees = arrayListOf<Person>()
    fun calculateSalary() {
        for (person in allEmployees) { /* ... */ }
    }
}

Payroll.allEmployees.add(Person(...))
Payroll.calculateSalary()

object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
        return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}
```
</details>

<details>
    <summary>companion object: place for factory method and static members</summary>
    
```kotlin
class A {
    companion object {
        fun bar() {
            println("Companion object called")
        }
    }
}

A.bar()
```
</details>

<details>
    <summary>object expression: creating anonymous objects</summary>
    
```kotlin
fun countClicks(window: Window) {
    var clickCount = 0
    window.addMouseListener(object : MouseAdapter() {
        override fun mouseClicked(e: MouseEvent) {
            clickCount++
        }
    })
}
```

</details>